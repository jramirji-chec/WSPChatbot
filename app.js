const { createBot, createProvider, createFlow, addKeyword,EVENTS } = require('@bot-whatsapp/bot')
const QRPortalWeb = require('@bot-whatsapp/portal')
const BaileysProvider = require('@bot-whatsapp/provider/baileys')
const MockAdapter = require('@bot-whatsapp/database/mock')
const fs = require("fs") // para poder leer el archivo del path
const path = require("path");
const csv = require("csv-parser");
const { spawn } = require('child_process');
//const { handlerAI } = require("./speechToText") // para poder usar la funci√≥n de transcripci√≥n
const { handlerAI } = require("./speechToText_solojs") // para poder usar la funci√≥n de transcripci√≥n
const { delay } = require('@whiskeysockets/baileys')
const { buscarPorNombre } = require("./Leer_archivos"); // Importar la funci√≥n desde Leer_archivos.js
const { buscarPorCedula } = require("./Leer_archivos"); // Importar la funci√≥n desde Leer_archivos.js
const sharedData = {};


// const usersData = {}; // Almac√©n temporal de datos de usuarios
// const csvFilePath = "reportes.csv"; // Ruta del archivo CSV
const jsonFilePath = path.join(__dirname, "reportes.json"); // Ruta del archivo JSON

//const csvFilePath = path.join(__dirname, "reportes.csv");
const usersData = {}; // Almac√©n temporal de datos de usuarios

// FUNCION PARA ELIMINAR ACENTOS
function eliminarAcentos(texto) {
    return texto.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
// FUNCION PARA DAR ESPERA ENTRE ACCIONES
function espera(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

// Flujo principal
const flowPrincipal = addKeyword(['hola', 'ole', 'alo'])
    .addAnswer("¬°Hola, estamos validando tu informaci√≥n, por favor espera un momento...üîÑ", null, async (ctx, ctxFn) => {
        // Esperar 5 segundos antes de continuar
        await espera(5000);

        const userId = ctx.from;
        let encontrado = false;
        let Nnombre = "";
        let Ncedula = "";
        let Ntelefono = "";
        let Ncodigo = "";

        try {
            // Leer el archivo JSON
            let jsonData = [];
            if (fs.existsSync(jsonFilePath)) {
                const fileContent = fs.readFileSync(jsonFilePath, "utf8");
                jsonData = JSON.parse(fileContent);
            }

            // Buscar el n√∫mero de tel√©fono en los datos del JSON
            const usuario = jsonData.find((row) => row.telefono === userId);
            

            if (usuario) {
                encontrado = true;
                Nnombre = usuario.nombre;
                Ncedula = usuario.cedula;
                Ntelefono = usuario.telefono;
                Ncodigo = usuario.codigo;

                console.log("El nombre es:", Nnombre);
                console.log("La c√©dula es:", Ncedula);
                console.log("El tel√©fono es:", Ntelefono);
                console.log("El c√≥digo es:", Ncodigo);

                usersData[userId] = {
                    nombre: Nnombre,
                    cedula: Ncedula,
                    telefono: Ntelefono,
                    codigo: Ncodigo,
                    fechaHora: new Date().toLocaleString("es-ES").replace(",", ""), // Formatear fecha y hora
                };

                await ctxFn.flowDynamic(`¬°Bienvenido de nuevo, *${Nnombre}*! üòä`);
                await espera(2000);
                await ctxFn.flowDynamic("Por favor, env√≠ame una nota de voz que sea clara y pausada, describiendo tu reporte o incidente.");
            } else {
                // Redirigir al flujo `flujoInicial` si el n√∫mero no existe
                await ctxFn.gotoFlow(flujoInicial);
            }
        } catch (error) {
            console.error("Error al leer el archivo JSON:", error);
            await ctxFn.flowDynamic("Lo siento, ocurri√≥ un error al verificar tu informaci√≥n. Por favor, intenta m√°s tarde.");
        }
    });


// Flujo inicial
const flujoInicial = addKeyword(['hola', 'ole', 'alo'])
    .addAnswer("¬°Bienvenido! Soy *ChatbotCHEC*.", { delay: 2000 })
    .addAnswer("Ac√° puedes reportar incidentes, a trav√©s de notas de voz.", { delay: 500 })
    .addAnswer(
        "Para comenzar, indica para qui√©n vas a realizar el reporte, responde con:\n\n1Ô∏è‚É£ Reporte a mi Nombre.\n2Ô∏è‚É£ Reporte a Nombre de otra persona.",
        { delay: 2000, capture: true },async (ctx, { gotoFlow, fallBack }) => {
            const opcion = ctx.body.trim();
            sharedData.opcionSeleccionada = opcion; // Guardar en el objeto compartido
            //console.log("Opci√≥n seleccionada:", sharedData.opcionSeleccionada);

            if (opcion === '1') {
                return gotoFlow(flujoNombrePropio);
            } else if (opcion === '2') {
                return gotoFlow(flujoValidarOtro);
            } else {
                return fallBack("Opci√≥n no v√°lida. Por favor, responde con 1 o 2.");
            }
        }
    );

// Flujo para validar remitente por nombre propio
const flujoNombrePropio = addKeyword('flujoPropio')
    .addAnswer("Por favor, ind√≠came tu *Nombre completo* para validar los datos:", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
        const userId = ctx.from;
        const nombre = eliminarAcentos(ctx.body.trim());

        await flowDynamic("Estamos validando tu informaci√≥n, por favor espera un momento...üîÑ");
        await espera(3000);

        const resultados = await buscarPorNombre(nombre);

        if (resultados.length === 0) {
            await flowDynamic("‚ùå No se encontraron datos para la persona ingresada. Por favor verifica el nombre y vuelve a intentarlo.");
            return gotoFlow(flujoInicial);
        }

        if (resultados.length === 1) {
            const r = resultados[0];
            usersData[userId] = {
                remitente: {
                    nombre: r.nombre,
                    cedula: r.cedula,
                    codigo: r.usuario
                }
            };

            await flowDynamic(`‚úÖ ¬°Hola, *${r.nombre}*!\nT√∫ c√©dula es: *${r.cedula}*\nT√∫ c√≥digo es: *${r.usuario}*`);
            //return gotoFlow(flujoValidarDestino);
            await espera(1000);
            await flowDynamic("Ahora, por favor env√≠ame una *nota de voz* con el reporte del incidente.");
            return;
        }

        if (resultados.length > 1) {
        // Hay m√°s de un resultado, mostrar opciones
        await procesarMultiplesCoincidencias(resultados, state, flowDynamic);
        return gotoFlow(flujoSeleccionMultiplesCoincidencias);
        }        
    })
    


async function procesarMultiplesCoincidencias(resultados, state, flowDynamic) {
    const opcionesTexto = resultados.map((r, i) => `*${i + 1}*. ${r.nombre}`).join('\n');
    await flowDynamic(`‚ö†Ô∏è Se encontraron m√∫ltiples coincidencias:\n\n${opcionesTexto}`);
    await state.update({ posiblesCoincidencias: resultados });
}

const flujoSeleccionMultiplesCoincidencias = addKeyword('seleccionMultiplesCoincidencias')
    .addAnswer("Por favor selecciona un n√∫mero de la lista...", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
        const userId = ctx.from;
        const seleccion = parseInt(ctx.body.trim());
        const posibles = state.get("posiblesCoincidencias");

        if (!posibles || isNaN(seleccion) || seleccion < 1 || seleccion > posibles.length) {
            await flowDynamic("‚ùå Opci√≥n inv√°lida. Por favor escribe el n√∫mero correcto de la lista mostrada.");
            return;
        }

        const seleccionado = posibles[seleccion - 1];
        usersData[userId] = {
            remitente: {
                nombre: seleccionado.nombre,
                cedula: seleccionado.cedula,
                codigo: seleccionado.usuario
            }
        };

        await flowDynamic(`‚úÖ ¬°Hola, *${seleccionado.nombre}*!\nTu c√©dula es: *${seleccionado.cedula}*\nTu c√≥digo es: *${seleccionado.usuario}*`);
        //return gotoFlow(flujoValidarDestino);
        // Usar el valor en otra funci√≥n
        if (sharedData.opcionSeleccionada=== '1') {
            console.log("Opci√≥n seleccionada:", sharedData.opcionSeleccionada);
            await flowDynamic("Ahora, por favor env√≠ame una *nota de voz* que sea clara y pausada con el reporte del incidente.");
        }
        if (sharedData.opcionSeleccionada=== '2') {
            console.log("Opci√≥n seleccionada:", sharedData.opcionSeleccionada);
            //await flowDynamic("Ahora: ¬øCu√°l es el *Nombre Completo* de la persona para quien haces el reporte?");
            //return gotoFlow(flujoNombrePropio);
            return gotoFlow(flujoValidarDestino);
            //return gotoFlow(flujoValidarOtro);
        }

        // Resetear la variable al finalizar el flujo
    sharedData.opcionSeleccionada = null;
        
        
    });
const flujoSeleccionMultiplesCoincidencias2 = addKeyword('seleccionMultiplesCoincidencias2')
    .addAnswer("Por favor selecciona un n√∫mero de la lista...", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
        const userId = ctx.from;
        const seleccion = parseInt(ctx.body.trim());
        const posibles = state.get("posiblesCoincidencias");

        if (!posibles || isNaN(seleccion) || seleccion < 1 || seleccion > posibles.length) {
            await flowDynamic("‚ùå Opci√≥n inv√°lida. Por favor escribe el n√∫mero correcto de la lista mostrada.");
            return;
        }

        const seleccionado = posibles[seleccion - 1];
        usersData[userId] = {
            remitente: {
                nombre: seleccionado.nombre,
                cedula: seleccionado.cedula,
                codigo: seleccionado.usuario
            }
        };

        await flowDynamic(`‚úÖ ¬°Hola, *${seleccionado.nombre}*!\nTu c√©dula es: *${seleccionado.cedula}*\nTu c√≥digo es: *${seleccionado.usuario}*`);
        //return gotoFlow(flujoValidarDestino);
        // Usar el valor en otra funci√≥n
        console.log("Opci√≥n seleccionada:", sharedData.opcionSeleccionada);
        await flowDynamic("Ahora, por favor env√≠ame una *nota de voz* que sea clara y pausada con el reporte del incidente.");
       

        // Resetear la variable al finalizar el flujo
    sharedData.opcionSeleccionada = null;
        
    });


 const flujoValidarOtro = addKeyword('validarOtro')
    .addAnswer("Por favor, ind√≠came tu Nombre y Apellido para validar los datos:", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
        const userId = ctx.from;
        const nombre = eliminarAcentos(ctx.body.trim());

        await flowDynamic("Estamos validando tu informaci√≥n, por favor espera un momento...üîÑ");
        await espera(3000);

        const resultados = await buscarPorNombre(nombre);


        if (resultados.length === 0) {
            await flowDynamic("‚ùå No se encontraron datos para la persona buscada. Por favor vuelve a intentarlo.");
            await espera(3000);
            return gotoFlow(flujoInicial);
        }

        if (resultados.length === 1) {
            const r = resultados[0];
            usersData[userId] = {
                remitente: {
                    nombre: r.nombre,
                    cedula: r.cedula,
                    codigo: r.usuario
                }
            };

            await flowDynamic(`‚úÖ ¬°Hola, *${r.nombre}*!\nT√∫ c√©dula es: *${r.cedula}*\nT√∫ c√≥digo es: *${r.usuario}*`);
            return gotoFlow(flujoValidarDestino);
            // await espera(1000);
            // await flowDynamic("Ahora, por favor env√≠ame una *nota de voz* con el reporte del incidente.");
            // return;
        }

        if (resultados.length > 1) {
        // Hay m√°s de un resultado, mostrar opciones
        await procesarMultiplesCoincidencias(resultados, state, flowDynamic);
        return gotoFlow(flujoSeleccionMultiplesCoincidencias);
        }    
    })

// // Paso 4: flujo para validar destinatario del reporte
const flujoValidarDestino = addKeyword('validarDestino')
    .addAnswer("Ahora: ¬øCu√°l es el *Nombre Completo* de la persona para quien haces el reporte?", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
        const userId = ctx.from;
        const nombre = eliminarAcentos(ctx.body.trim());

        await flowDynamic("Buscando los datos de esta persona...üîç");
        await espera(3000);

        const resultados = await buscarPorNombre(nombre);
        if (resultados.length === 0) {
            await flowDynamic("‚ùå No se encontraron datos. Por favor verifica el nombre y vuelve a intentarlo.");
            await espera(3000);
            return gotoFlow(flujoSeleccionManualOBusqueda);
        }
         if (resultados.length === 1) {
            const r = resultados[0];
            usersData[userId] = {
                remitente: {
                    nombre: r.nombre,
                    cedula: r.cedula,
                    codigo: r.usuario
                }
            };

            await flowDynamic(`‚úÖ ¬°La persona es, *${r.nombre}*!\nSu c√©dula es: *${r.cedula}*\nSu c√≥digo es: *${r.usuario}*`);
            //return gotoFlow(flujoValidarDestino);
            await espera(1000);
            await flowDynamic("Ahora, por favor env√≠ame una *nota de voz* con el reporte del incidente.");
            return;
        }

        if (resultados.length > 1) {
        // Hay m√°s de un resultado, mostrar opciones
        await procesarMultiplesCoincidencias(resultados, state, flowDynamic);
        return gotoFlow(flujoSeleccionMultiplesCoincidencias2);
        }    
    })


const flujoSeleccionManualOBusqueda = addKeyword('seleccionManualOBusqueda')
  .addAnswer(
    "¬øDeseas volver a buscar, o ingresar los datos manualmente?\n\n1Ô∏è‚É£ Volver a buscar.\n2Ô∏è‚É£ Ingresar datos manualmente.",
    { capture: true },
    async (ctx, { gotoFlow, fallBack }) => {
      const opcion = ctx.body.trim();
      console.log("Opci√≥n seleccionada:", opcion);

      if (opcion === '1') {
        return gotoFlow(flujoValidarDestino); // o el flujo de b√∫squeda original
      } else if (opcion === '2') {
        return gotoFlow(Nuevapersona); // flujo de ingreso manual
      } else {
        return fallBack("Opci√≥n no v√°lida. Por favor responde con 1 o 2.");
      }
    }
  );

//Flujo para ingresar datos de la nueva persona en caso de que no exista
const Nuevapersona = addKeyword('Nuevapersona') //{ capture: true }, async (ctx, { state }) => {     // { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
  // Paso 1: Nombre completo
  .addAnswer("üìù Por favor ingresa los *Nombres y Apellidos* completos:", { capture: true }, async (ctx, { state }) => {
    const nombre = ctx.body.trim();
    await state.update({ nombreManual: nombre });
  })

  // Paso 2: C√©dula
  .addAnswer("üî¢ Ingresa el n√∫mero de *c√©dula* (7 a 10 d√≠gitos):", { capture: true }, async (ctx, { state, flowDynamic, fallBack }) => {
    const cedula = ctx.body.trim();

    if (!/^\d{7,10}$/.test(cedula)) {
      await flowDynamic("‚ùå La c√©dula debe contener entre *7 y 10 d√≠gitos num√©ricos*. Intenta nuevamente.");
      return fallBack();
    }

    await state.update({ cedulaManual: cedula });
  })

  // Paso 3: Tel√©fono
  .addAnswer("üì± Ingresa el n√∫mero de *tel√©fono* (7 a 10 d√≠gitos):", { capture: true }, async (ctx, { state, flowDynamic, fallBack }) => {
    const telefono = ctx.body.trim();

    if (!/^\d{7,10}$/.test(telefono)) {
      await flowDynamic("‚ùå El n√∫mero de tel√©fono debe tener entre *7 y 10 d√≠gitos*. Intenta nuevamente.");
      return fallBack();
    }

    await state.update({ telefonoManual: telefono });

    // Mostrar resumen
    const nombre = await state.get("nombreManual");
    const cedula = await state.get("cedulaManual");

    await flowDynamic(`‚úÖ *Datos ingresados:*\nüìå Nombre: *${nombre}*\nü™™ C√©dula: *${cedula}*\nüìû Tel√©fono: *${telefono}*`);
  })

  .addAnswer("¬øSon correctos? Responde con:\n1Ô∏è‚É£ S√≠, son correctos.\n2Ô∏è‚É£ No, quiero volver a ingresarlos.", { capture: true }, async (ctx, { gotoFlow, flowDynamic, state }) => {
    const userId = ctx.from;
    const opcion = ctx.body.trim();

    const nombre = state.get("nombreManual");
    const cedula = state.get("cedulaManual");
    const telefono = state.get("telefonoManual");

    if (opcion === "1") {
      usersData[userId] = {
        nombre,
        cedula,
        telefono,
        fechaHora: new Date().toLocaleString("es-ES").replace(",", ""),
      };

      await flowDynamic("‚úÖ Los datos han sido guardados correctamente.\n\nAhora, por favor env√≠ame una *nota de voz* con el reporte del incidente.");
    } else if (opcion === "2") {
      return gotoFlow(Nuevapersona); // reiniciar ingreso manual
    } else {
      return await flowDynamic("‚ùå Opci√≥n no v√°lida. Por favor, responde con 1 o 2.");
    }
  });

// const Nuevapersona = addKeyword(['datosManual', 'ingresarDatos'])

//   // Paso 1: Nombre completo
//   .addAnswer("üìù Por favor ingresa los *Nombres y Apellidos* completos:", { capture: true }, async (ctx, { state }) => {
//     const nombre = ctx.body.trim();
//     await state.update({ nombreManual: nombre });
//   })

//   // Paso 2: C√©dula
//   .addAnswer("üî¢ Ingresa el n√∫mero de *c√©dula* (7 a 10 d√≠gitos):", { capture: true }, async (ctx, { state, flowDynamic, fallBack }) => {
//     const cedula = ctx.body.trim();

//     if (!/^\d{7,10}$/.test(cedula)) {
//       await flowDynamic("‚ùå La c√©dula debe contener entre *7 y 10 d√≠gitos num√©ricos*. Intenta nuevamente.");
//       return fallBack();
//     }

//     await state.update({ cedulaManual: cedula });
//   })

//   // Paso 3: Tel√©fono
//   .addAnswer("üì± Ingresa el n√∫mero de *tel√©fono* (7 a 10 d√≠gitos):", { capture: true }, async (ctx, { state, flowDynamic, fallBack }) => {
//     const telefono = ctx.body.trim();

//     if (!/^\d{7,10}$/.test(telefono)) {
//       await flowDynamic("‚ùå El n√∫mero de tel√©fono debe tener entre *7 y 10 d√≠gitos*. Intenta nuevamente.");
//       return fallBack();
//     }

//     await state.update({ telefonoManual: telefono });

//     // Mostrar resumen
//     const nombre = await state.get("nombreManual");
//     const cedula = await state.get("cedulaManual");

//     await flowDynamic(`‚úÖ *Datos ingresados:*\nüìå Nombre: *${nombre}*\nü™™ C√©dula: *${cedula}*\nüìû Tel√©fono: *${telefono}*`);
//   })

//   // Paso 4: Confirmaci√≥n final
//   .addAnswer("¬øSon correctos estos datos?\n\n1Ô∏è‚É£ S√≠, continuar.\n2Ô∏è‚É£ No, quiero volver a ingresarlos.",
//     { capture: true },
//     async (ctx, { gotoFlow, fallBack }) => {
//       const opcion = ctx.body.trim();

//       if (opcion === "1") {
//         await flowDynamic("‚úÖ Perfecto. Los datos han sido registrados.");
//         // Puedes redirigir a otro flujo si quieres:
//         // return gotoFlow(siguienteFlujo);
//       } else if (opcion === "2") {
//         await flowDynamic("üîÅ Vamos a volver a ingresar los datos.");
//         return  gotoFlow(Nuevapersona); // Reinicia el flujo
//       } else {
//         return fallBack("‚ùå Opci√≥n no v√°lida. Por favor responde con 1 o 2.");
//       }
//     }
//   );

// Flujo para manejar la nota de voz 
const flowVoice = addKeyword(EVENTS.VOICE_NOTE).addAnswer("Procesando nota de voz...üîÑ", null, async (ctx, ctxFn) => {
    try {
        const userId = ctx.from;
        const text = await handlerAI(ctx); // Convertir la nota de voz a texto

        // Reemplazar comas por puntos
        const textoSinComas = text.replace(/,/g, "."); // Reemplaza todas las comas por puntos
        const textoSinAcentos = eliminarAcentos(textoSinComas); // Elimina los acentos del texto

        console.log(`Texto procesado: ${textoSinAcentos}`);

        if (!usersData[userId]) usersData[userId] = {}; // Asegurar que el objeto existe
        usersData[userId].texto = textoSinAcentos; // Guardar el texto procesado sin las comas

        await ctxFn.flowDynamic(`*Transcripci√≥n*: ${textoSinAcentos}`); // Mostrar texto procesado con comas
        await espera(4000);
        await ctxFn.flowDynamic(
                        "Si est√°s de acuerdo con la transcripci√≥n, responde con:\n\n1Ô∏è‚É£ S√≠, estoy de acuerdo.\n2Ô∏è‚É£ No, quiero volver a enviarla.",
                        { delay: 500 }
                    );

        
    } catch (error) {
        console.error("Error en el flujo de notas de voz:", error);
        await ctxFn.flowDynamic("Lo siento, no pude procesar tu nota de voz.");
    }
});



// Flujo para manejar la respuesta del usuario despu√©s de la transcripci√≥n
const flowWelcome = addKeyword(EVENTS.WELCOME)
.addAction(async (ctx, ctxFn) =>{
    const userId = ctx.from;
    //const respuesta = ctx.body.trim();
    if (ctx.body.includes("1")){
        if (usersData[userId].nombre && usersData[userId].cedula && usersData[userId].codigo && usersData[userId].texto) {
        //writeToCSV(usersData[userId]); // Guardar en el CSV
            writeToJSON(usersData[userId]); // Guardar en el archivo JSON
            delete usersData[userId]; // Limpiar el almacenamiento del usuario
    }
        await ctxFn.flowDynamic("¬°Gracias por utilizar *ChatbotCHEC*! Te esperamos pronto. üëã");
    }else if (ctx.body.includes("2")){
        await ctxFn.flowDynamic("Por favor, vuelve a enviar tu nota de voz para procesarla nuevamente.");
    }else if (["3", "4", "5", "6", "7", "8", "9", "0"].includes(ctx.body)) {
        await ctxFn.flowDynamic("Opci√≥n no v√°lida. Por favor, responde con 1Ô∏è‚É£ o 2Ô∏è‚É£.");
    }else {
        await ctxFn.gotoFlow(flowPrincipal); // Vuelve a preguntar hasta que ingrese 1 o 2
    console.log("Valor capturado: ",ctx.body) // Con esta funcion, imprimimos lo que escribio el usuario en WSP en la consola PC
    // await ctxFn.flowDynamic(`Bienvenido: ${ctx.body}`);  
}
}
)


// üîπ Funci√≥n para escribir en el archivo JSON
const writeToJSON = (data) => {
    let jsonData = [];

    // Leer el archivo JSON si ya existe
    if (fs.existsSync(jsonFilePath)) {
        const fileContent = fs.readFileSync(jsonFilePath, "utf8");
        jsonData = JSON.parse(fileContent);
    }

    // Agregar los nuevos datos al arreglo
    jsonData.push(data);

    // Escribir el arreglo actualizado en el archivo JSON
    fs.writeFileSync(jsonFilePath, JSON.stringify(jsonData, null, 4), "utf8");
};

// üîπ Funci√≥n para escribir en el archivo CSV
const writeToCSV = (data) => {
    const headers = "Nombre,Cedula,Telefono,Codigo,Texto Procesado,Fecha y Hora\n";

    if (!fs.existsSync(csvFilePath)) {
        fs.writeFileSync(csvFilePath, headers); // Crear archivo con encabezados si no existe
    }

    // Insertar los datos en una sola l√≠nea
    const row = `${data.nombre},${data.cedula},${data.telefono},${data.codigo},${data.texto},${data.fechaHora}\n`;
    fs.appendFileSync(csvFilePath, row, "utf8");
};


const main = async () => {
    const adapterDB = new MockAdapter()  //flujoValidarRemitente,flujoValidarDestino
    const adapterFlow = createFlow([flowPrincipal,flujoNombrePropio,flujoValidarOtro,flujoValidarDestino,flujoInicial,flowWelcome, flowVoice,flujoSeleccionMultiplesCoincidencias,flujoSeleccionMultiplesCoincidencias2,flujoSeleccionManualOBusqueda,Nuevapersona])
    const adapterProvider = createProvider(BaileysProvider)

    createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
    })

    QRPortalWeb()
}

main()
